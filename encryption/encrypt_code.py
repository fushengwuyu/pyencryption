#!/usr/bin/env python3
"""
Python项目加密工具 - 改进版
将指定目录下的Python文件编译为.so/.pyd文件
"""

import os
import time
import shutil
import logging
import argparse
import pathlib
from distutils.core import setup
from Cython.Build import cythonize
from setuptools import find_packages
from pathlib import Path

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def parse_args():
    """解析命令行参数"""
    parser = argparse.ArgumentParser(description='Python项目加密工具')
    parser.add_argument("--except_dirs", help="排除目录", default='', type=str, nargs='+')
    parser.add_argument("--enc_dir", help="要加密的目录", required=True, type=str)
    parser.add_argument("--build_dir", help="输出目录", required=True, type=str)
    parser.add_argument("--entrance", help="入口文件名", default="", type=str)
    return parser.parse_args()


class ProjectEncryptor:
    def __init__(self, args):
        self.args = args
        self.start_time = time.time()
        self.ignore_dirs = ['.venv', '.idea', '__pycache__', '.git', '.cache']

        # 标准化路径
        self.curr_dir = pathlib.Path(args.enc_dir).resolve()
        self.build_dir = pathlib.Path(args.build_dir).resolve()
        self.build_tmp_dir = self.build_dir / "temp"
        self.except_dirs = [Path(d).resolve() for d in args.except_dirs]
        # 确保输出目录存在
        self.build_dir.mkdir(parents=True, exist_ok=True)

    def ensure_init_py(self, root_dir):
        """确保所有子目录都有__init__.py"""
        for root, dirs, _ in os.walk(root_dir):
            for d in dirs:
                init_path = os.path.join(root, d, "__init__.py")
                if not os.path.exists(init_path):
                    with open(init_path, "w") as f:
                        f.write("# auto-generated by build script\n")
                    print(f"Created {init_path}")

    def get_py_files(self):
        """获取所有需要编译的Python文件"""
        py_files = []
        # except_dirs = [pathlib.Path(d) for d in self.args.except_dirs]

        for py_file in self.curr_dir.rglob("*.py"):
            # 跳过排除目录
            if any(py_file.is_relative_to(e) for e in self.except_dirs):
                continue

            # 跳过特殊文件和目录
            if any(part in self.ignore_dirs for part in py_file.parts):
                continue

            # 跳过__init__.py和入口文件
            if py_file.name.startswith('__') or py_file.name == self.args.entrance:
                continue

            py_files.append(str(py_file))

        return py_files

    def compile_python(self, py_files):
        """编译Python文件"""
        if not py_files:
            raise ValueError("没有找到可编译的Python文件")

        try:
            setup(
                ext_modules=cythonize(
                    py_files,
                    compiler_directives={'language_level': "3"},
                    build_dir=str(self.build_tmp_dir)
                ),
                script_args=["build_ext", "-b", str(self.build_dir), "-t", str(self.build_tmp_dir)],
                packages=find_packages(where=str(self.curr_dir)),
                options={"build_ext": {"inplace": False}},
            )
        except Exception as e:
            logger.error(f"编译失败: {str(e)}")
            self.cleanup()
            raise

    def copy_non_py_files(self):
        """复制非Python文件"""
        for item in self.curr_dir.rglob('*'):
            # 跳过忽略目录
            if any(part in self.ignore_dirs for part in item.parts):
                continue

            relative = item.relative_to(self.curr_dir)
            target = self.build_dir / relative

            # 处理需要保留的文件
            if item.is_file():
                if (item.suffix not in ('.py', '.pyc', '.c') or
                        item.name == '__init__.py' or
                        item.name == self.args.entrance):
                    target.parent.mkdir(parents=True, exist_ok=True)
                    shutil.copy2(item, target)

    def cleanup(self):
        """清理临时文件"""
        if self.build_tmp_dir.exists():
            shutil.rmtree(self.build_tmp_dir)

        # 删除生成的.c文件
        for c_file in self.curr_dir.rglob("*.c"):
            c_file.unlink()

    def run(self):
        """执行加密流程"""
        try:
            logger.info("开始项目加密...")
            # 0. 补全__init__.py
            self.ensure_init_py(self.curr_dir)
            # 1. 获取Python文件
            py_files = self.get_py_files()
            logger.info(f"找到 {len(py_files)} 个Python文件需要编译")

            # 2. 编译Python文件
            self.compile_python(py_files)

            # 3. 复制非Python文件
            self.copy_non_py_files()

            # 4. 清理临时文件
            self.cleanup()

            elapsed = time.time() - self.start_time
            logger.info(f"加密完成! 耗时: {elapsed:.2f}秒")

        except Exception as e:
            logger.error(f"加密过程出错: {str(e)}")
            self.cleanup()
            return 1

        return 0


if __name__ == '__main__':
    args = parse_args()
    encryptor = ProjectEncryptor(args)
    exit(encryptor.run())
